/**
 CW Keyer
 CW Key logic change with ron's code (ubitx_keyer.cpp)
 Ron's logic has been modified to work with the original uBITX by KD8CEC

 Original Comment ----------------------------------------------------------------------------
 * The CW keyer handles either a straight key or an iambic / paddle key.
 * They all use just one analog input line. This is how it works.
 * The analog line has the internal pull-up resistor enabled. 
 * When a straight key is connected, it shorts the pull-up resistor, analog input is 0 volts
 * When a paddle is connected, the dot and the dash are connected to the analog pin through
 * a 10K and a 2.2K resistors. These produce a 4v and a 2v input to the analog pins.
 * So, the readings are as follows :
 * 0v - straight key
 * 1-2.5 v - paddle dot
 * 2.5 to 4.5 v - paddle dash
 * 2.0 to 0.5 v - dot and dash pressed
 * 
 * The keyer is written to transparently handle all these cases
 * 
 * Generating CW
 * The CW is cleanly generated by unbalancing the front-end mixer
 * and putting the local oscillator directly at the CW transmit frequency.
 * The sidetone, generated by the Arduino is injected into the volume control
 */


// in milliseconds, this is the parameter that determines how long the tx will hold between cw key downs
//#define CW_TIMEOUT (600l)   //Change to CW Delaytime for value save to eeprom
#define PADDLE_DOT 1
#define PADDLE_DASH 2
#define PADDLE_BOTH 3
#define PADDLE_STRAIGHT 4

//we store the last padde's character 
//to alternatively send dots and dashes 
//when both are simultaneously pressed
char lastPaddle = 0;

//reads the analog keyer pin and reports the paddle
byte getPaddle(){
  int paddle = analogRead(ANALOG_KEYER);
  if (paddle > 2800)      return 0;               // above 4v is up
  if (paddle > 2400)      return PADDLE_DASH;     // 4-3v is dot
  else if (paddle > 1050) return PADDLE_DOT;      // 1-2v is dash
  else if (paddle > 700)   return PADDLE_BOTH;    // both are between 1 and 2v
  else                    return PADDLE_STRAIGHT; // less than 1v is the straight key
/**  if (paddle > 800)      return 0;              // above 4v is up
  if (paddle > 600)      return PADDLE_DASH;     // 4-3v is dot
  else if (paddle > 300) return PADDLE_DOT;      // 1-2v is dash
  else if (paddle > 50)  return PADDLE_BOTH;     // both are between 1 and 2v
  else                   return PADDLE_STRAIGHT; // less than 1v is the straight key**/
}

/**
 * Starts transmitting the carrier with the sidetone
 * It assumes that we have called cwTxStart and not called cwTxStop
 * each time it is called, the cwTimeOut is pushed further into the future
 */
void cwKeydown(){
  keyDown = 1;                  //tracks the CW_KEY
  tone(CW_TONE, (int)conf.sideTone); 
  digitalWrite(CW_KEY, 1);     
  //Modified by KD8CEC, for CW Delay Time save to eeprom
  //cwTimeout = millis() + CW_TIMEOUT;
  conf.cwTimeout = millis() + conf.cwDelayTime * 10;  
}

void tone(byte pin, unsigned int freq) { ledcWriteTone(0,conf.sideTone); } // generar tono de freq en el pin
  
void noTone(byte pin) { ledcWriteTone(0,0); }       // parar tono en el pin

/** Stops the cw carrier transmission along with the sidetone
 * Pushes the cwTimeout further into the future   */
void cwKeyUp(){
  keyDown = 0;    //tracks the CW_KEY
  noTone(CW_TONE);
  digitalWrite(CW_KEY, 0);    
  
  //Modified by KD8CEC, for CW Delay Time save to eeprom
  //cwTimeout = millis() + CW_TIMEOUT;
  conf.cwTimeout = millis() + conf.cwDelayTime * 10;
}

//Variables for Ron's new logic
#define DIT_L 0x01 // DIT latch
#define DAH_L 0x02 // DAH latch
#define DIT_PROC 0x04 // DIT is being processed
#define PDLSWAP 0x08 // 0 for normal, 1 for swap
#define IAMBICB 0x10 // 0 for Iambic A, 1 for Iambic B
enum KSTYPE {IDLE, CHK_DIT, CHK_DAH, KEYED_PREP, KEYED, INTER_ELEMENT };
static unsigned long ktimer;
unsigned char keyerState = IDLE;

//Below is a test to reduce the keying error. do not delete lines
//create by KD8CEC for compatible with new CW Logic
char update_PaddleLatch(byte isUpdateKeyState) {
  unsigned char tmpKeyerControl = 0;
  int paddle = analogRead(ANALOG_KEYER);
  if (paddle >= conf.cwAdcDashFrom && paddle <= conf.cwAdcDashTo)
    tmpKeyerControl |= DAH_L;
  else if (paddle >= conf.cwAdcDotFrom && paddle <= conf.cwAdcDotTo)
    tmpKeyerControl |= DIT_L;
  else if (paddle >= conf.cwAdcBothFrom && paddle <= conf.cwAdcBothTo)
    tmpKeyerControl |= (DAH_L | DIT_L) ;     
  else 
    {
//    if (Iambic_Key)
    if (conf.cwKeyType>0)
      tmpKeyerControl = 0 ;
    else if (paddle >= conf.cwAdcSTFrom && paddle <= conf.cwAdcSTTo)
      tmpKeyerControl = DIT_L ;
     else
       tmpKeyerControl = 0 ; 
    }
  
  if (isUpdateKeyState == 1)
    keyerControl |= tmpKeyerControl;

  return tmpKeyerControl;
}

/*****************************************************************************
// New logic, by RON
// modified by KD8CEC
******************************************************************************/
void cwKeyer(void){
  lastPaddle=0;
  bool continue_loop = true;
  unsigned tmpKeyControl = 0;
//  if (Iambic_Key ) 
  if (conf.cwKeyType>0)
    {
    while(continue_loop) {
      switch (keyerState) {
        case IDLE:
          tmpKeyControl = update_PaddleLatch(0);
          if ( tmpKeyControl == DAH_L || tmpKeyControl == DIT_L || 
            tmpKeyControl == (DAH_L | DIT_L) || (keyerControl & 0x03)) {
             update_PaddleLatch(1);
             keyerState = CHK_DIT;
          }else{
            if (0 < conf.cwTimeout && conf.cwTimeout < millis()){
              conf.cwTimeout = 0;
              stopTx();
            }
            continue_loop = false;
          }
          break;
        case CHK_DIT:
          if (keyerControl & DIT_L) {
            keyerControl |= DIT_PROC;
            ktimer = conf.cwSpeed;
            keyerState = KEYED_PREP;
          }else{
            keyerState = CHK_DAH;
          }
          break;
        case CHK_DAH:
          if (keyerControl & DAH_L) {
            ktimer = conf.cwSpeed*3;
            keyerState = KEYED_PREP;
          }else{
            keyerState = IDLE;
          }
          break;
        case KEYED_PREP:
          //modified KD8CEC
          /*
          ktimer += millis(); // set ktimer to interval end time
          keyerControl &= ~(DIT_L + DAH_L); // clear both paddle latch bits
          keyerState = KEYED; // next state
          if (!inTx){
            //DelayTime Option
            delay_background(delayBeforeCWStartTime * 2, 2,1);
            
            keyDown = 0;
            cwTimeout = millis() + cwDelayTime * 10;  //+ CW_TIMEOUT;
            startTx(TX_CW, 1);
          }
          */
          if (!inTx){
            //DelayTime Option
            delay_background(conf.delayBeforeCWStartTime * 2, 2,1);
            keyDown = 0;
            conf.cwTimeout = millis() + conf.cwDelayTime * 10;  //+ CW_TIMEOUT;
            startTx(TX_CW, 1);
          }
          ktimer += millis(); // set ktimer to interval end time
          keyerControl &= ~(DIT_L + DAH_L); // clear both paddle latch bits
          keyerState = KEYED; // next state
          cwKeydown();
          break;
        case KEYED:
          if (millis() > ktimer) { // are we at end of key down ?
           cwKeyUp();
           ktimer = millis() + conf.cwSpeed; // inter-element time
            keyerState = INTER_ELEMENT; // next state
          }else if (keyerControl & IAMBICB) {
            update_PaddleLatch(1); // early paddle latch in Iambic B mode
          }
          break;
        case INTER_ELEMENT:   // Insert time between dits/dahs
          update_PaddleLatch(1); // latch paddle state
          if (millis() > ktimer) { // are we at end of inter-space ?
            if (keyerControl & DIT_PROC) { // was it a dit or dah ?
              keyerControl &= ~(DIT_L + DIT_PROC); // clear two bits
              keyerState = CHK_DAH; // dit done, check for dah
            }else{
              keyerControl &= ~(DAH_L); // clear dah latch
              keyerState = IDLE; // go idle
            }
          }
          break;
      }
  
      Check_Cat(2);
    } //end of while
    }
  else      // not Iambic_Key
    {
    while(1)
      {
      if (update_PaddleLatch(0) == DIT_L) 
        {
          s2("update_PaddleLatch");s2(crlf);
        // if we are here, it is only because the key is pressed
        if (!inTx)
          {
          //DelayTime Option
          delay_background(conf.delayBeforeCWStartTime*2, 2,1);
          keyDown = 0;
          conf.cwTimeout = millis() + conf.cwDelayTime * 10;  //+ CW_TIMEOUT; 
          startTx(TX_CW, 1);
          }
        cwKeydown();
        while (update_PaddleLatch(0) == DIT_L ) { delay_background(1,3,1); }
        cwKeyUp();
        }
      else
        {
        if (0 < conf.cwTimeout && conf.cwTimeout < millis())
          {
          conf.cwTimeout = 0;
          keyDown = 0;
          stopTx();
          }
        return;                   //Tx stop control by Main Loop
        }
      Check_Cat(2);
      } //end of while
    }   //end of else
}
